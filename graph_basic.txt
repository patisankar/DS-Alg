# how to create adj list in graph

Map<Integer, List<int[]>> adj = new HashMap<>();

for(int[] time : times){
  int source = time[0];
  adj.computeIfAbsent(souce, k-> new ArrayList<>()).add(new int[]{time[1], time[2});
}

# priority Queue
PriorityQueue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(a->a[0]));
or
PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[0], a[0]));

Queue<Integer> q = new ArrayDeque<>();

common mistakes
================

1. In shortest-path graph problems, using a simple visited array is a frequent and fundamental mistake. The correct mental model is distance relaxation, not node visitation
2. The heap can contain stale entries for the same node, so we must ignore any popped distance that’s worse than the current best in the distance array.

for (edge u → v) {
        if (dist[u] + w < dist[v]) {
            dist[v] = dist[u] + w;
            pq.add(dist[v], v);
        }
    }
